samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 33)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,33]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
spec_all.df = as.data.frame(spec_all)
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 10,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 35)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,35]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
warnings()
spec_wet = readRDS("Clean-up/Vector_normalized/vn_all_w.rds")
spec_es = spec_wet[meta(spec_wet)$Location == "Eagle Summit",]
spec_all = spec_es
names(spec_all) = meta(spec_all)$Species
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 37)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,37]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
spec_dry = readRDS("Clean-up/Vector_normalized/all_vn.rds")
spec_es_d = spec_dry[meta(spec_wet)$Location == "Eagle Summit",]
spec_all = spec_es_d
names(spec_all) = meta(spec_all)$Species
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
spec_dry = readRDS("Clean-up/Vector_normalized/all_vn.rds")
spec_es_d = spec_dry[meta(spec_dry)$Location == "Eagle Summit",]
spec_all = spec_es_d
names(spec_all) = meta(spec_all)$Species
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
###ncomp = 35
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 24)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,24]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
spec_wet = readRDS("Clean-up/Vector_normalized/vn_all_w.rds")
spec_es = spec_wet[meta(spec_wet)$Location == "Eagle Summit",]
spec_es_nohyb = spec_es[!meta(spec_es)$Species == "hybrid",]
spec_all = spec_es_nohyb
names(spec_all) = meta(spec_all)$Species
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
###ncomp = 37
spec_wet = readRDS("Clean-up/Vector_normalized/vn_all_w.rds")
spec_es = spec_wet[meta(spec_wet)$Location == "Eagle Summit",]
spec_es_nohyb = spec_es[!meta(spec_es)$Species == "hybrid",]
spec_all = spec_es_nohyb
names(spec_all) = meta(spec_all)$Species
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 26)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,26]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
spec_dry = readRDS("Clean-up/Vector_normalized/all_vn.rds")
spec_es_d = spec_dry[meta(spec_dry)$Location == "Eagle Summit",]
spec_es_d_nohyb = spec_es_d[!meta(spec_es_d)$Species == "hybrid",]
spec_all = spec_es_d_nohyb
names(spec_all) = meta(spec_all)$Species
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
#Run PLSDA
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 15)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,15]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
################################################################################
# Fit PLS_DA model wet ES nohyb
################################################################################
#data
spec_wet = readRDS("Clean-up/Vector_normalized/vn_all_w.rds")
m_wet = meta(spec_wet)
View(m_wet)
View(spec_wet)
View(spec_wet[["dryala-wdb1_00080.sed"]])
s16 = spec_wet[16,]
meta(s16)
?`meta<-
/
?
?meat4
afsdfs
f
library("spectrolab")
?meta
library("spectrolab")
################################################################################
#Prerequisite functions
################################################################################
#add metadata to raw spectra
add_meta <- function(spectra_path, metadata_path){
spectra_raw = read_spectra(path = spectra_path, format = "sed")
metadata = read.csv(file = metadata_path, header = TRUE, stringsAsFactors = FALSE)
meta(spectra_raw) <- metadata
return(spectra_raw)
}
#The goal of the following functions is to keep the 4 spectral measurements that
#are closest to the mean reflectance values for each individual plant. The
#sample design involved stacking leaves 3 times and taking 2 reflectance
#measurements per stack interval. Therefore, the first stack tended to have much
#of the black background showing, and the third stack probably had more light
#reflected from the leaves than observed in nature (think about how stacking a
#leaf would simulate scanning a thicker leaf). The idea here is that restricting
#measurements to the 3 closest to the mean should provide more data to work with
#compared to just taking the mean while also removing high and low reflectance
#measurements caused by sample design.
#subtract the mean reflectance from measured reflectance (i.e. calculate
#distance from the mean)
center_scale = function(spectra){
scale(spectra, scale = FALSE)
}
#rank spectra by distance from the mean
dist.rank = function(spectra){
rank(rowSums(abs(center_scale(spectra))))
}
#keep the 4 spectra per individual plant that are closest to the mean
keep = function(spectra){
a = dist.rank(spectra)
x1 = subset(spectra, a < 5)
}
#split the spectra objects to individual plants, apply above funtions, and
#recombine them.
trim.spectra = function(spectra){
spec.list = lapply(split(spectra, meta(spectra)$Name), keep)
clean_spec = Reduce(combine, spec.list)
return(clean_spec)
}
################################################################################
#Primary functions
################################################################################
#This function adds the metadata, cuts spectra to wavelength 400:2400, removes
#reflectance values greater than 1, reduces the data to the 4 measurements
#that are closest to the mean for each individual and smooths the spectra.
thebigclean <- function(spectra_path, metadata_path){
meta.spectra = add_meta(spectra_path, metadata_path)
spectra_cut = meta.spectra[, 400:2400]
spec1 = spectra_cut[!rowSums(spectra_cut > 1),]
spec2 = trim.spectra(spec1)
clean_spectra = smooth(spec2)
return(clean_spectra)
}
################################################################################
#Set working directory to folder containing downloaded spectral data
################################################################################
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
es_w_path = "Scans_raw/Wet Scans/es_wet"
es_w_meta = "Scans_raw/Wet Scans/es_wet/es_wet_meta.csv"
es_w_clean = thebigclean(es_w_path, es_w_meta)
vn_es_w = normalize(es_w_clean)
#Wickersham Dome A
wda_w_path = "Scans_raw/Wet Scans/wda_wet"
wda_w_meta = "Scans_raw/Wet Scans/wda_wet/wda_wet_meta.csv"
wda_w_clean = thebigclean(wda_w_path, wda_w_meta)
vn_wda_w = normalize(wda_w_clean)
#Wickerhamd Dome B
wdb_w_path = "Scans_raw/Wet Scans/wdb_wet"
wdb_w_meta = "Scans_raw/Wet Scans/wdb_wet/wdb_wet_meta.csv"
wdb_w_clean = thebigclean(wdb_w_path, wdb_w_meta)
vn_wdb_w = normalize(wdb_w_clean)
#all wet
Clean_all_w = Reduce(combine, list(wdb_w_clean, wda_w_clean, es_w_clean))
vn_all_w = normalize(Clean_all_w)
saveRDS(Clean_all_w, "Clean-up/Clean_spectra/clean_all_w.rds")
saveRDS(vn_all_w, "Clean-up/Vector_normalized/vn_all_w.rds")
es = vn_all_w[meta(vn_all_w)$Location =="Eagle Summit",]
meta(es)
library(mixOmics)
library(spectrolab)
library(plotrix)
################################################################################
#Set working directory to folder containing downloaded rds files
################################################################################
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
spec_wet = readRDS("Clean-up/Vector_normalized/vn_all_w.rds")
spec_es = spec_wet[meta(spec_wet)$Location == "Eagle Summit",]
spec_all = spec_es
names(spec_all) = meta(spec_all)$Species
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 25)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,25]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
#data
spec_wet = readRDS("Clean-up/Vector_normalized/vn_all_w.rds")
spec_es = spec_wet[meta(spec_wet)$Location == "Eagle Summit",]
spec_es_nohyb = spec_es[!meta(spec_es)$Species == "hybrid",]
spec_all = spec_es_nohyb
names(spec_all) = meta(spec_all)$Species
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 22)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,22]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
