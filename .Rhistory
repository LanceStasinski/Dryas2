p = .8,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model: 10-fold cross-validation repeated 3 times
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = 'down',
repeats = 3)
#Fit model. Note max iterations set to 10000 to allow model convergence
plsFit <- train(
Location ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
#variable importance
vip = varImp(plsFit)
bg = assign(paste0('bg', i), vip$importance$`Bison Gulch`)
bg.vip <- cbind(bg.vip, get('bg'))
es = assign(paste0('es', i), vip$importance$`Eagle Summit`)
es.vip <- cbind(es.vip, get('es'))
md = assign(paste0('md', i), vip$importance$`Murphy Dome B`)
md.vip <- cbind(md.vip, get('md'))
tm = assign(paste0('tm', i), vip$importance$`Twelve Mile`)
tm.vip <- cbind(tm.vip, get('tm'))
wda = assign(paste0('wda', i), vip$importance$`Wickersham Dome A`)
wda.vip <- cbind(wda.vip, get('wda'))
wdb = assign(paste0('wdb', i), vip$importance$`Wickersham Dome B`)
wdb.vip <- cbind(wdb.vip, get('wdb'))
#accuracy objects for determining n components
a = assign(paste0('a', i), as.matrix(plsFit$results$Accuracy))
a.fit <- cbind(a.fit, get('a'))
#test model using the testing data partition (30% of data)
plsClasses <- predict(plsFit, newdata = testing)
#confusion/classification matrix objects to assess accuracy
cm = confusionMatrix(data = plsClasses, as.factor(testing$Location))
cm.m = assign(paste0("cm", i), as.matrix(cm))
cm.list <- list.append(cm.list, get('cm.m'))
ac <- assign(paste0('acc',i), cm$overall[1])
accuracy <- append(accuracy, get('ac'))
kap = assign(paste0("kap",i), cm$overall[2])
kappa <- append(kappa, get('kap'))
}
m = as.matrix(spec_all)
ncol(m)
warning()
warnings()
################################################################################
a.total = a.fit[,-1]
a.avg = as.matrix(rowMeans(a.total))
a.sd = as.matrix(rowSds(a.total))
a.lower = a.avg - a.sd
a.higher = a.avg + a.sd
#Graph to visually choose optimal number of components
x = 1:60
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(x, a.avg, type = 'p', pch = 16, cex = .75, ylab = 'Accuracy',
xlab = 'Component', xlim = c(1,60), main = 'Accuracy for Species_ID',
ylim = c(0,1))
arrows(x, a.lower, x, a.higher,length=0.05, angle=90, code=3)
abline(v = 18, col = 'blue')
abline(h = max(a.avg), col = "Red")
legend('bottomright', legend = c('Mean', 'Maximum accuracy','Best component'),
pch = c(16, NA, NA), lty = c(NA, 1, 1), col = c('black', 'red', 'blue'))
max(a.avg)
a.avg
#data
spec_all = readRDS("Clean-up/Clean_spectra/clean_all_6scans.rds")
spec_all = spec_all[, 750:2400]
spec_all = spec_all[, -seq(1400, 1500, by = 1)]
spec_all = spec_all[, -seq(1890, 1990, by = 1)]
#remove any NaN values - mostly pertains to populations
spec_all = spec_all[!meta(spec_all)$Location == "NaN",]
spec_mat = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#combine relavant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df$Location)
colnames(spec_df)[colnames(spec_df) == "spec_all.df$Location"] <- "Location"
################################################################################
#Run PLSDA
################################################################################
#Set number of components to be used
ncomp = 54
#create vectors, lists, and matrices to store metrics and loadings
accuracy <- c()
kappa <- c()
a.fit <- matrix(nrow = ncomp)
cm.list <- list()
bg.vip = matrix(nrow=1449)
es.vip = matrix(nrow=1449)
md.vip = matrix(nrow=1449)
tm.vip = matrix(nrow=1449)
wda.vip = matrix(nrow=1449)
wdb.vip = matrix(nrow=1449)
#start of PLSDA code
for(i in 1:10){
#create data partition: 70% of data for training, 30% for testing
inTrain <- caret::createDataPartition(
y = spec_df$Location,
p = .8,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model: 10-fold cross-validation repeated 3 times
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
sampling = 'up',
repeats = 3)
#Fit model. Note max iterations set to 10000 to allow model convergence
plsFit <- train(
Location ~ .,
data = training,
maxit = 100000,
method = "pls",
trControl = ctrl,
tuneLength = ncomp)
#variable importance
vip = varImp(plsFit)
bg = assign(paste0('bg', i), vip$importance$`Bison Gulch`)
bg.vip <- cbind(bg.vip, get('bg'))
es = assign(paste0('es', i), vip$importance$`Eagle Summit`)
es.vip <- cbind(es.vip, get('es'))
md = assign(paste0('md', i), vip$importance$`Murphy Dome B`)
md.vip <- cbind(md.vip, get('md'))
tm = assign(paste0('tm', i), vip$importance$`Twelve Mile`)
tm.vip <- cbind(tm.vip, get('tm'))
wda = assign(paste0('wda', i), vip$importance$`Wickersham Dome A`)
wda.vip <- cbind(wda.vip, get('wda'))
wdb = assign(paste0('wdb', i), vip$importance$`Wickersham Dome B`)
wdb.vip <- cbind(wdb.vip, get('wdb'))
#accuracy objects for determining n components
a = assign(paste0('a', i), as.matrix(plsFit$results$Accuracy))
a.fit <- cbind(a.fit, get('a'))
#test model using the testing data partition (30% of data)
plsClasses <- predict(plsFit, newdata = testing)
#confusion/classification matrix objects to assess accuracy
cm = confusionMatrix(data = plsClasses, as.factor(testing$Location))
cm.m = assign(paste0("cm", i), as.matrix(cm))
cm.list <- list.append(cm.list, get('cm.m'))
ac <- assign(paste0('acc',i), cm$overall[1])
accuracy <- append(accuracy, get('ac'))
kap = assign(paste0("kap",i), cm$overall[2])
kappa <- append(kappa, get('kap'))
}
mean.acc = mean(accuracy)
sd.acc = sd(accuracy)
mean.kap = mean(kappa)
sd.kap = sd(kappa)
mean.acc
sd.acc
mean.kap
sd.kap
cm.avg = Reduce('+', cm.list)/100
cm.avg = t(cm.avg)
cm.total = cm.avg/rowSums(cm.avg)
cm.total = as.data.frame(cm.total)
cm.total = cm.total %>% replace_with_na_all(condition = ~.x == 0)
cm.total = as.matrix(cm.total)
rownames(cm.total) <- c('BG', 'ES', 'MD', 'TM', 'WDA', 'WDB')
colnames(cm.total) <- c('BG', 'ES', 'MD', 'TM', 'WDA', 'WDB')
cols = colorRampPalette(c('#f5f5f5', '#fe9929'))
par(mar = c(1,2,2,1), oma = c(1,1,3,1))
corrplot::corrplot(cm.total,
is.corr = T,
method = 'square',
col = cols(10),
addCoef.col = '#542788',
tl.srt = 0,
tl.offset = 1,
number.digits = 2,
tl.cex = 1.2,
cl.cex = 1,
number.cex = 1.5,
tl.col = 'black',
cl.pos = 'n',
na.label = 'square',
na.label.col = 'white',
addgrid.col = 'grey')
vip_to_spec = function(x){
t.vip = t(x)
colnames(t.vip) <- seq(400,2400, by = 1)
s.vip = as_spectra(t.vip)
}
bg.vip = bg.vip[,-1]
bg.vip.spec = vip_to_spec(bg.vip)
es.vip = es.vip[,-1]
es.vip.spec = vip_to_spec(es.vip)
md.vip = md.vip[,-1]
md.vip.spec = vip_to_spec(md.vip)
tm.vip = tm.vip[,-1]
tm.vip.spec = vip_to_spec(tm.vip)
wda.vip = wda.vip[,-1]
wda.vip.spec = vip_to_spec(wda.vip)
wdb.vip = wdb.vip[,-1]
wdb.vip.spec = vip_to_spec(wdb.vip)
#plot
par(mfrow = c(3,2))
plot(mean(bg.vip.spec), lwd = 2, lty = 1, col = rgb(0,0,0,1),
cex.lab = 1.25, ylim = c(0, 100), ylab = "Variable Importance",
xlab = NA, main = 'Bison Gulch')
plot_quantile(bg.vip.spec, total_prob = 0.95, col = rgb(0,0,0, 0.25),
border = FALSE, add = TRUE)
abline(v = 1450, lty = 2, lwd = 1.5)
abline(v = 1940, lty = 2, lwd = 1.5)
plot(mean(es.vip.spec), lwd = 2, lty = 1, col = rgb(0,0,0,1),
cex.lab = 1.25, ylim = c(0, 100), ylab = NA,
xlab = NA, main = 'Eagle Summit')
plot_quantile(es.vip.spec, total_prob = 0.95, col = rgb(0,0,0, 0.25),
border = FALSE, add = TRUE)
abline(v = 1450, lty = 2, lwd = 1.5)
abline(v = 1940, lty = 2, lwd = 1.5)
plot(mean(md.vip.spec), lwd = 2, lty = 1, col = rgb(0,0,0,1),
cex.lab = 1.25, ylim = c(0, 100), ylab = "Variable Importance",
xlab = NA, main = 'Murphy Dome')
plot_quantile(md.vip.spec, total_prob = 0.95, col = rgb(0,0,0, 0.25),
border = FALSE, add = TRUE)
abline(v = 1450, lty = 2, lwd = 1.5)
abline(v = 1940, lty = 2, lwd = 1.5)
plot(mean(tm.vip.spec), lwd = 2, lty = 1, col = rgb(0,0,0,1),
cex.lab = 1.25, ylim = c(0, 100), ylab = NA,
xlab = NA, main = 'Twelve Mile')
plot_quantile(tm.vip.spec, total_prob = 0.95, col = rgb(0,0,0, 0.25),
border = FALSE, add = TRUE)
abline(v = 1450, lty = 2, lwd = 1.5)
abline(v = 1940, lty = 2, lwd = 1.5)
plot(mean(wda.vip.spec), lwd = 2, lty = 1, col = rgb(0,0,0,1),
cex.lab = 1.25, ylim = c(0, 100), ylab = 'Variable Importance',
xlab = 'Wavelength (nm)', main = 'Wickersham Dome A')
plot_quantile(wda.vip.spec, total_prob = 0.95, col = rgb(0,0,0, 0.25),
border = FALSE, add = TRUE)
abline(v = 1450, lty = 2, lwd = 1.5)
abline(v = 1940, lty = 2, lwd = 1.5)
plot(mean(wdb.vip.spec), lwd = 2, lty = 1, col = rgb(0,0,0,1),
cex.lab = 1.25, ylim = c(0, 100), ylab = NA,
xlab = 'Wavelength (nm)', main = 'Wickersham Dome B')
plot_quantile(wdb.vip.spec, total_prob = 0.95, col = rgb(0,0,0, 0.25),
border = FALSE, add = TRUE)
abline(v = 1450, lty = 2, lwd = 1.5)
abline(v = 1940, lty = 2, lwd = 1.5)
library(caret)
library(plsRbeta)
library(pls)
library(spectrolab)
library(matrixStats)
library(tidyverse)
library(rlist)
library(caret)
library(plsRbeta)
library(pls)
library(spectrolab)
library(matrixStats)
library(tidyverse)
library(rlist)
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
################################################################################
#Set up
################################################################################
#spectra
spec_all= readRDS("Clean-up/Clean_spectra/clean_all_6scans.rds")
#remove NAs
spec_all = spec_all[!meta(spec_all)$DA == "NaN",]
#prepare data for PLS
spectra.df = as.data.frame(spec_all)
spectra.m = as.matrix(spec_all)
spec_df = as.data.frame(spectra.m)
spec_df = cbind(spec_df, spectra.df$DA)
colnames(spec_df)[colnames(spec_df) == 'spectra.df$DA'] <- 'DA'
################################################################################
#Training and testing sets - all
################################################################################
#10-fold cross validation repeated 5 times
plsFit = PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
warnings()
plsFit$results_kfolds
#Acquire statistics from each repeat
plsFit.info = kfolds2CVinfos_beta(plsFit)
plsFit.info
plsFit.info[[1]][,1]
setwd('"C:/Users/istas/OneDrive/Documents/GitHub/Dryas2/Data')
saveRDS(spec_all, 'clean_all_6scans.rds')
setwd('C:/Users/istas/OneDrive/Documents/GitHub/Dryas2/Data')
saveRDS(spec_all, 'clean_all_6scans.rds')
setwd('C:/Users/istas/OneDrive/Documents/GitHub/Dryas2')
saveRDS(plsFit, file = paste0('Models/plsBeta/plsFit_', i, '.rds'))
i = 1
saveRDS(plsFit, file = paste0('Models/plsBeta/plsFit_', i, '.rds'))
saveRDS(plsFit.info, paste0('Models/plsBeta/pls_info_', i, '.rds'))
?PLS_beta_kfoldcv_formula
################################################################################
#Set up
################################################################################
#spectra
spec_all= readRDS("Data/clean_all_6scans.rds")
spec_all = spec_all[!meta(spec_all)$DA == "NaN",]
#prepare data for PLS
spectra.df = as.data.frame(spec_all)
spectra.m = as.matrix(spec_all)
spec_df = as.data.frame(spectra.m)
spec_df = cbind(spec_df, spectra.df$DA)
colnames(spec_df)[colnames(spec_df) == 'spectra.df$DA'] <- 'DA'
################################################################################
#Training and testing sets - all
################################################################################
for (i in 1:2) {
#10-fold cross validation repeated 5 times
plsFit = PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
saveRDS(plsFit, file = paste0('Models/plsBeta/plsFit_', i, '.rds'))
#Acquire statistics from each repeat
plsFit.info = kfolds2CVinfos_beta(plsFit)
saveRDS(plsFit.info, paste0('Models/plsBeta/pls_info_', i, '.rds'))
}
install.packages('parallel')
install.packages("parallel")
install.packages('foreach')
install.packages("foreach")
install.packages('doParallel')
library(caret)
library(plsRbeta)
library(pls)
library(spectrolab)
library(matrixStats)
library(tidyverse)
library(rlist)
library(parallel)
library(foreach)
library(doParallel)
################################################################################
#Training and testing sets - all
################################################################################
numCores = detectCores()
numCores
spec_all= readRDS("Data/clean_all_6scans.rds")
#remove NAs
spec_all = spec_all[!meta(spec_all)$DA == "NaN",]
#prepare data for PLS
spectra.df = as.data.frame(spec_all)
spectra.m = as.matrix(spec_all)
spec_df = as.data.frame(spectra.m)
spec_df = cbind(spec_df, spectra.df$DA)
colnames(spec_df)[colnames(spec_df) == 'spectra.df$DA'] <- 'DA'
################################################################################
#Training and testing sets - all
################################################################################
numCores = detectCores()
registerDoParallel(numCores)
foreach (i = 1:2) %dopar% {
#10-fold cross validation repeated 5 times
plsFit = PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
saveRDS(plsFit, file = paste0('Models/plsBeta/plsFit_', i, '.rds'))
#Acquire statistics from each repeat
plsFit.info = kfolds2CVinfos_beta(plsFit)
saveRDS(plsFit.info, paste0('Models/plsBeta/pls_info_', i, '.rds'))
}
################################################################################
library(caret)
library(plsRbeta)
library(pls)
library(spectrolab)
library(matrixStats)
library(tidyverse)
library(rlist)
library(parallel)
library(foreach)
library(doParallel)
foreach (i = 1:2) %dopar% {
#10-fold cross validation repeated 5 times
plsFit = PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
saveRDS(plsFit, file = paste0('Models/plsBeta/plsFit_', i, '.rds'))
#Acquire statistics from each repeat
plsFit.info = kfolds2CVinfos_beta(plsFit)
saveRDS(plsFit.info, paste0('Models/plsBeta/pls_info_', i, '.rds'))
}
foreach (i = 1:2) %dopar% {
PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
}
library(caret)
library(plsRbeta)
library(pls)
library(spectrolab)
library(matrixStats)
library(tidyverse)
library(rlist)
library(parallel)
library(foreach)
library(doParallel)
################################################################################
#Set up
################################################################################
#spectra
spec_all= readRDS("Data/clean_all_6scans.rds")
#remove NAs
spec_all = spec_all[!meta(spec_all)$DA == "NaN",]
#prepare data for PLS
spectra.df = as.data.frame(spec_all)
spectra.m = as.matrix(spec_all)
spec_df = as.data.frame(spectra.m)
spec_df = cbind(spec_df, spectra.df$DA)
colnames(spec_df)[colnames(spec_df) == 'spectra.df$DA'] <- 'DA'
################################################################################
#Training and testing sets - all
################################################################################
numCores = detectCores()
registerDoParallel(numCores)
foreach (i = 1:2) %dopar% {
PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
}
foreach (i = 1:2) %dopar% {
plsRbeta::PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
}
foreach (i = 1:2) %dopar% {
library(plsRbeta)
plsRbeta::PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
}
foreach (i = 1:2) %dopar% {
library(plsRbeta)
plsFit = plsRbeta::PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
}
object = foreach (i = 1:2) %dopar% {
library(plsRbeta)
plsFit = plsRbeta::PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
}
View(object)
object[[1]]
#Acquire statistics from each repeat
plsFit.info = kfolds2CVinfos_beta(object[[1]])
pls_info = foreach (i = 1:2) %dopar% {
library(plsRbeta)
plsRbeta::kfolds2CVinfos_beta(plsFit[[i]])
}
pls_info = foreach (i = 1:2) %dopar% {
library(plsRbeta)
plsRbeta::kfolds2CVinfos_beta(object[[i]])
}
pls_info = foreach (i = 1:2) %dopar% {
library(plsRbeta)
library(spectrolab)
spec_all= readRDS("Data/clean_all_6scans.rds")
#remove NAs
spec_all = spec_all[!meta(spec_all)$DA == "NaN",]
#prepare data for PLS
spectra.df = as.data.frame(spec_all)
spectra.m = as.matrix(spec_all)
spec_df = as.data.frame(spectra.m)
spec_df = cbind(spec_df, spectra.df$DA)
colnames(spec_df)[colnames(spec_df) == 'spectra.df$DA'] <- 'DA'
plsRbeta::kfolds2CVinfos_beta(object[[i]])
}
plsFit = foreach (i = 1:2) %dopar% {
library(plsRbeta)
m = plsRbeta::PLS_beta_kfoldcv_formula(DA~., data = spec_df, nt = 2,
modele = 'pls-beta', K = 2, NK = 1,
verbose = T, random = T)
info = plsRbeta::kfolds2CVinfos_beta(m)
}
pls_info_list = list()
for(i in 1:5) {
pls_info = plsRbeta::kfolds2CVinfos_beta(object[[i]])
info = assign(paste0("pls_info", i), pls_info)
pls_info_list = list.append(pls_info_list, get('info'))
}
pls_info_list[[1]]
avg(pls_info_list[[1]], pls_info_list[[2]])
mean(pls_info_list[[1]], pls_info_list[[2]])
mean(pls_info_list[[1]][,1], pls_info_list[[2]][,1])
mean(pls_info_list[[1]][1,1], pls_info_list[[2]][1,1])
pls_info_list[[1]]
pls_info_list[[1]][,1]
pls_info_list[[1]][1]
pls_info_list[[1]][[,1]]
pls_info_list[[1]][,1]]
pls_info_list[[1]][[1]]
x = pls_info_list[[1]]
x
x[1]
x[,1]
xm = as.matrix(x)
xm
View(xm)
x[2]
View(pls_info_list)
df = as.data.frame(x)
View(df)
df$AIC
pls_info_list[[2]]
pls_info_list
