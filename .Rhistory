perf.plot_species = plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 50)
perf.plot_species = plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 40)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,26]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
################################################################################
# Fit PLS_DA model all
################################################################################
#data
spec_all = readRDS("Clean-up/Clean_spectra/spec_iS50.rds")
head(meta(spec_all))
library(spectrolab)
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0/Scans_raw/iS50/ES/iS50_ESA")
################################################################################
#format csv function
################################################################################
#format csvs output by iS50 into those that can be read as spectra
format.spec.csv = function(x){
spec1 = t(read.csv(x, head = F))
colnames(spec1) <- spec1[1,]
spec2 = t(as.data.frame(spec1[-1,]))
rownames(spec2) <- x
return(spec2)
}
#convert csvs to spectra then smooth spectra
csv.to.spec = function(files){
csv.stack = do.call(rbind, lapply(files, format.spec.csv))
spectra = smooth(as.spectra(csv.stack))
}
################################################################################
#create spectra from csvs
################################################################################
#ES
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0/Scans_raw/iS50/ES/iS50_ESA")
es = list.files()
es_iS50 = csv.to.spec(es)
#TM
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0/Scans_raw/iS50/TM/iS50_TM")
tm = list.files()
tm_iS50 = csv.to.spec(tm)
#WDB
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0/Scans_raw/iS50/WDB/iS50_WDB")
wdb = list.files()
wdb_iS50 = csv.to.spec(wdb)
################################################################################
#Add Meta Data
################################################################################
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0/Scans_raw/iS50")
es_meta = read.csv(file = "ES/es_iS50.csv", header = TRUE, stringsAsFactors = FALSE)
meta(es_iS50) <- es_meta
tm_meta = read.csv("TM/tm_iS50.csv", header = TRUE, stringsAsFactors = FALSE)
meta(tm_iS50) <- tm_meta
wdb_meta = read.csv("WDB/wdb_iS50.csv", header = TRUE, stringsAsFactors = FALSE)
meta(wdb_iS50) <- wdb_meta
################################################################################
#combine
################################################################################
spec_iS50 = Reduce(spectrolab::combine, list(es_iS50, tm_iS50, wdb_iS50))
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0/Clean-up/Clean_spectra")
saveRDS(spec_iS50, "spec_iS50.rds")
head(meta(spec_iS50))
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
################################################################################
# Fit PLS_DA model all
################################################################################
#data
spec_all = readRDS("Clean-up/Clean_spectra/spec_iS50.rds")
spec_all = spec_all[!meta(spec_all)$Species_ID == "NaN",]
names(spec_all) = meta(spec_all)$Species_ID
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(4000, 11999, by = 100))
spec_small = spec_all
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 40)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 50)
perf.plot_species = plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
warnings()
plotIndiv(plsda.fit, title = "", comp = c(1,2,5), legend = TRUE,
style = "3d", ind.names = F, ellipse = TRUE)
plotIndiv(plsda.fit, title = "", comp = c(1,2,3), legend = TRUE,
style = "3d", ind.names = F, ellipse = TRUE)
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 40)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,35]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,21]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,40]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,36]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,34]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,33]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,32]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,31]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,30]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,29]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
?mtext
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
mtext("Predict Species iS50 scans", side = 3)
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1, line = -1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
mtext("Predict Species iS50 scans", side = 3, line = 2)
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1, line = -1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
mtext("Predict Species iS50 scans, 27 comps, 0.2169 BER", side = 3, line = 1.5)
spec_h = spec_all[meta(spec_all)$Species_ID == "DX",]
spec_h
#data
spec_all = readRDS("Clean-up/Clean_spectra/spec_iS50.rds")
spec_all = spec_all[!meta(spec_all)$Species_ID == "NaN",]
spec_all = spec_all[!meta(spec_all)$Species_ID == "DX",]
names(spec_all) = meta(spec_all)$Species_ID
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(4000, 11999, by = 100))
spec_small = spec_all
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 3,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
perf.plot_species = plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,17]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,24]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,16]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,19]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,14]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,15]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,15]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1, line = -1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
mtext("Predict Species iS50 scans (No Hybrids), 15 comps, 0.1296 BER", side = 3, line = 1.5)
################################################################################
# Fit PLS_DA model all
################################################################################
#data
spec_all = readRDS("Clean-up/Clean_spectra/spec_iS50.rds")
names(spec_all) = meta(spec_all)$Location
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(4000, 11999, by = 100))
spec_small = spec_all
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 3,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
perf.plot_species = plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,21]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,20]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,19]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,22]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,21]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,23]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,24]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,25]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,26]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
prediction <- test.predict$class$max.dist[,23]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1, line = -1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
mtext("Predict Location iS50 scans, 23 comps, 0.03243 BER", side = 3, line = 1.5)
par(mar = c(2, 5, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1, line = -1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
mtext("Predict Location iS50 scans, 23 comps, 0.03243 BER", side = 3, line = 1.5)
plot(spec_all)
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
################################################################################
# Fit PLS_DA model all
################################################################################
#data
spec_all = readRDS("Clean-up/Vector_normalized/all_vn.rds")
spec_es = spec_all[meta(spec_all)$Location == "Eagle Summit",]
spec_wdb = spec_all[meta(spec_all)$Location == "Wickersham Dome B",]
spec_tm = spec_all[meta(spec_all)$Location == "Twelve Mile",]
spec_all = Reduce(combine, list(spec_es, spec_wdb, spec_tm))
names(spec_all) = meta(spec_all)$Species_ID
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
################################################################################
# Fit PLS_DA model all
################################################################################
#data
spec_all = readRDS("Clean-up/Vector_normalized/all_vn.rds")
spec_es = spec_all[meta(spec_all)$Location == "Eagle Summit",]
spec_wdb = spec_all[meta(spec_all)$Location == "Wickersham Dome B",]
spec_tm = spec_all[meta(spec_all)$Location == "Twelve Mile",]
spec_all = Reduce(spectrolab::combine, list(spec_es, spec_wdb, spec_tm))
names(spec_all) = meta(spec_all)$Species_ID
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 40)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,26]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
par(mar = c(2, 5, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1, line = -1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
mtext("Predict Species, 3 sites, 26 comps, 0.2051 BER", side = 3, line = 1.5)
