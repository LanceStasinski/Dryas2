class(loadings.m) <- 'matrix'
assign(paste0('lm',i), loadings.m)
comp1 = loadings.m[,1]
assign(paste0('comp1_',i), comp1)
comp2 = loadings.m[,2]
assign(paste0('comp2_',i), comp2)
comp3 = loadings.m[,3]
assign(paste0('comp3_',i), comp3)
#test model
plsClasses <- predict(plsFit, newdata = testing)
#Confusion matrices
cm = confusionMatrix(data = plsClasses, testing$Location)
acc = cm$overall[1]
assign(paste0('acc',i), acc)
kap = cm$overall[2]
assign(paste0("kap",i), kap)
cm.m = as.matrix(cm)
assign(paste0("cm", i), cm.m)
}
acc = c(acc1, acc2, acc3, acc4, acc5, acc6, acc7, acc8, acc9, acc10)
mean.acc = mean(acc)
sd.acc = sd(acc)
kap = c(kap1, kap2, kap3, kap4, kap5, kap6, kap7, kap8, kap9, kap10)
mean.kap = mean(kap)
sd.kap = sd(kap)
mean.acc
sd.acc
mean.kap
sd.kap
#data
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
spec_all = spec_all[!meta(spec_all)$Location == "NaN",]
spec_all = spec_all[,2000:2400]
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(2000, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
#combine relavant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df$Location)
colnames(spec_df)[colnames(spec_df) == "spec_all.df$Location"] <- "Location"
#Partition Data
for(i in 1:10){
set.seed(i)
inTrain <- caret::createDataPartition(
y = spec_df$Location,
p = .8,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
repeats = 3)
plsFit <- train(
Location ~ .,
data = spec_df,
maxit = 8000,
method = "pls",
trControl = ctrl,
tuneLength = 40)
assign(paste0('plsFit', i), plsFit)
loadings = plsFit$finalModel$loadings
loadings.m = as.matrix(loadings)
class(loadings.m) <- 'matrix'
assign(paste0('lm',i), loadings.m)
comp1 = loadings.m[,1]
assign(paste0('comp1_',i), comp1)
comp2 = loadings.m[,2]
assign(paste0('comp2_',i), comp2)
comp3 = loadings.m[,3]
assign(paste0('comp3_',i), comp3)
#test model
plsClasses <- predict(plsFit, newdata = testing)
#Confusion matrices
cm = confusionMatrix(data = plsClasses, testing$Location)
acc = cm$overall[1]
assign(paste0('acc',i), acc)
kap = cm$overall[2]
assign(paste0("kap",i), kap)
cm.m = as.matrix(cm)
assign(paste0("cm", i), cm.m)
}
acc = c(acc1, acc2, acc3, acc4, acc5, acc6, acc7, acc8, acc9, acc10)
mean.acc = mean(acc)
sd.acc = sd(acc)
kap = c(kap1, kap2, kap3, kap4, kap5, kap6, kap7, kap8, kap9, kap10)
mean.kap = mean(kap)
sd.kap = sd(kap)
mean.acc
sd.acc
mean.kap
sd.kap
#kappa
k1 = as.matrix(plsFit1$results$Kappa)
k2 = as.matrix(plsFit2$results$Kappa)
k3 = as.matrix(plsFit3$results$Kappa)
k4 = as.matrix(plsFit4$results$Kappa)
k5 = as.matrix(plsFit5$results$Kappa)
k6 = as.matrix(plsFit6$results$Kappa)
k7 = as.matrix(plsFit7$results$Kappa)
k8 = as.matrix(plsFit8$results$Kappa)
k9 = as.matrix(plsFit9$results$Kappa)
k10 = as.matrix(plsFit10$results$Kappa)
k.total = Reduce(cbind, list(k1,k2,k3,k4,k5,k6,k7,k8,k9,k10))
kavg = as.matrix(rowMeans(k.total))
ksd = as.matrix(rowSds(k.total))
klower = kavg - ksd
khigher = kavg + ksd
par(mar = c(5.1, 4.1, 4.1, 2.1), oma = c(5.1, 4.1, 4.1, 2.1))
plot(kavg, type = 'p', pch = 16, cex = .75, ylab = 'Kappa', xlab = 'Component',
xlim = c(0,40), main = 'Kappa for Location')
lines(klower, lty = 2, col = 'red')
lines(khigher, lty = 2, col = 'red')
abline(v = 20, col = 'blue')
legend('bottomright', legend = c('Mean', 'Standard deviation', 'Best component'),
pch = c(16, NA, NA), lty = c(NA, 2, 1), col = c('black', 'red', 'blue'))
#data
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
spec_all = spec_all[!meta(spec_all)$Location == "NaN",]
spec_all = spec_all[,2000:2400]
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(2000, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
#combine relavant meta data to matrix
spec_df = as.data.frame(spec_mat)
spec_df = cbind(spec_df, spec_all.df$Location)
colnames(spec_df)[colnames(spec_df) == "spec_all.df$Location"] <- "Location"
#Partition Data
for(i in 1:10){
set.seed(i)
inTrain <- caret::createDataPartition(
y = spec_df$Location,
p = .8,
list = FALSE
)
training <- spec_df[inTrain,]
testing <- spec_df[-inTrain,]
#tune model
ctrl <- trainControl(
method = "repeatedcv",
number = 10,
repeats = 3)
plsFit <- train(
Location ~ .,
data = spec_df,
maxit = 8000,
method = "pls",
trControl = ctrl,
tuneLength = 16)
assign(paste0('plsFit', i), plsFit)
loadings = plsFit$finalModel$loadings
loadings.m = as.matrix(loadings)
class(loadings.m) <- 'matrix'
assign(paste0('lm',i), loadings.m)
comp1 = loadings.m[,1]
assign(paste0('comp1_',i), comp1)
comp2 = loadings.m[,2]
assign(paste0('comp2_',i), comp2)
comp3 = loadings.m[,3]
assign(paste0('comp3_',i), comp3)
#test model
plsClasses <- predict(plsFit, newdata = testing)
#Confusion matrices
cm = confusionMatrix(data = plsClasses, testing$Location)
acc = cm$overall[1]
assign(paste0('acc',i), acc)
kap = cm$overall[2]
assign(paste0("kap",i), kap)
cm.m = as.matrix(cm)
assign(paste0("cm", i), cm.m)
}
acc = c(acc1, acc2, acc3, acc4, acc5, acc6, acc7, acc8, acc9, acc10)
mean.acc = mean(acc)
sd.acc = sd(acc)
kap = c(kap1, kap2, kap3, kap4, kap5, kap6, kap7, kap8, kap9, kap10)
mean.kap = mean(kap)
sd.kap = sd(kap)
mean.acc
sd.acc
mean.kap
sd.kap
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
vn.spec = normalize(spec_all)
library(spectrolab)
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
################################################################################
# Distance matrix
################################################################################
#data
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
vn.spec = normalize(spec_all)
spec_all_mat = as.matrix(spec_all)
?dist
spec_all_dist = dist(spec_all_mat)
image(spec_all_dist)
plot(spec_all_dist)
library(ape)
#Tree
tree = read.tree(file = "dyras_phylogeny.treefile")
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
#Tree
tree = read.tree(file = "dyras_phylogeny.treefile")
#Tree
tree = read.tree(file = "dryas_phylogeny.treefile")
?cophenetic
tree.dist = cophenetic(tree)
?mantel.test
tiplabels(tree)
View(tree.dist)
?aggregate.spectra
meta(spec_all)
spec.mean = aggregate(spec_all,
by = meta(spec_all)$Name,
mean, try_keep_txt(mean))
View(spec.mean)
spec_mat = as.matrix(spec.mean)
View(spec_mat)
ID = colnames(tree.dist)
?sort
ID = order(ID)
ID = colnames(tree.dist)
ID
ID
ID
sf
ID = sort(ID)
ID
ID
meta(spec.mean)
mean.meta = meta(spec.mean)
write.csv(mean.meta, file = "mean_meta.csv")
ID
library("spectrolab")
################################################################################
#Prerequisite functions
################################################################################
#add metadata to raw spectra
add_meta <- function(spectra_path, metadata_path){
spectra_raw = read_spectra(path = spectra_path, format = "sed")
metadata = read.csv(file = metadata_path, header = TRUE, stringsAsFactors = FALSE)
meta(spectra_raw) <- metadata
return(spectra_raw)
}
#The goal of the following functions is to keep the 4 spectral measurements that
#are closest to the mean reflectance values for each individual plant. The
#sample design involved stacking leaves 3 times and taking 2 reflectance
#measurements per stack interval. Therefore, the first stack tended to have much
#of the black background showing, and the third stack probably had more light
#reflected from the leaves than observed in nature (think about how stacking a
#leaf would simulate scanning a thicker leaf). The idea here is that restricting
#measurements to the 3 closest to the mean should provide more data to work with
#compared to just taking the mean while also removing high and low reflectance
#measurements caused by sample design.
#subtract the mean reflectance from measured reflectance (i.e. calculate
#distance from the mean)
center_scale = function(spectra){
scale(spectra, scale = FALSE)
}
#rank spectra by distance from the mean
dist.rank = function(spectra){
rank(rowSums(abs(center_scale(spectra))))
}
#keep the 4 spectra per individual plant that are closest to the mean
keep = function(spectra){
a = dist.rank(spectra)
x1 = subset(spectra, a < 5)
}
#split the spectra objects to individual plants, apply above funtions, and
#recombine them.
trim.spectra = function(spectra){
spec.list = lapply(split(spectra, meta(spectra)$Name), keep)
clean_spec = Reduce(combine, spec.list)
return(clean_spec)
}
################################################################################
#Primary functions
################################################################################
#This function adds the metadata, cuts spectra to wavelength 400:2400, removes
#reflectance values greater than 1, reduces the data to the 4 measurements
#that are closest to the mean for each individual and smooths the spectra.
thebigclean <- function(spectra_path, metadata_path){
meta.spectra = add_meta(spectra_path, metadata_path)
spectra_cut = meta.spectra[, 400:2400]
spec1 = spectra_cut[!rowSums(spectra_cut > 1),]
spec2 = trim.spectra(spec1)
clean_spectra = smooth(spec2)
return(clean_spectra)
}
################################################################################
#Set working directory to folder containing downloaded spectral data
################################################################################
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
################################################################################
#Twelve Mile
################################################################################
tm_path = "Scans_raw/Dry Scans/Twelve_Mile/12mile-dryas-08082019"
tm_meta = "Scans_raw/Dry Scans/Twelve_Mile/tm_pops.csv"
tm_clean1 = thebigclean(tm_path, tm_meta)
tm_clean = tm_clean1
bg_path = "Scans_raw/Dry Scans/Bison_Gulch/bisonGulch_dry"
bg_meta = "Scans_raw/Dry Scans/Bison_Gulch/bg_pops.csv"
bg_clean = thebigclean(bg_path, bg_meta)
es_path = "Scans_raw/Dry Scans/Eagle_Summit/es-dry"
es_meta = "Scans_raw/Dry Scans/Eagle_Summit/es_pops.csv"
es_clean1 = thebigclean(es_path, es_meta)
es_clean = es_clean1
mdb_path = "Scans_raw/Dry Scans/Murphy_Dome_B/murphyB-dry"
mdb_meta = "Scans_raw/Dry Scans/Murphy_Dome_B/mdb_pops.csv"
mdb_clean = thebigclean(mdb_path, mdb_meta)
wda_path = "Scans_raw/Dry Scans/Wickersham_A/wickershamdome-dry"
wda_meta = "Scans_raw/Dry Scans/Wickersham_A/wda_pops.csv"
wda_clean = thebigclean(wda_path, wda_meta)
wdb_path = "Scans_raw/Dry Scans/Wickersham_B/wdb-dry"
wdb_meta = "Scans_raw/Dry Scans/Wickersham_B/wdb_pops.csv"
wdb_clean = thebigclean(wdb_path, wdb_meta)
clean_all = Reduce(combine, list(tm_clean, es_clean, wdb_clean, mdb_clean,
wda_clean, bg_clean))
saveRDS(clean_all, "Clean-up/Clean_spectra/clean_all_phylo.rds")
spec_all = readRDS("Clean-up/Clean_spectra/clean_all_phylo.rds")
spec.mean = aggregate(spec_all,
by = meta(spec_all)$Name,
mean, try_keep_txt(mean))
mean.meta = meta(spec.mean)
write.csv(mean.meta, file = "mean_meta.csv")
write.csv(mean.meta, file = "mean_meta_new.csv")
tree = read.tree(file = "dryas_phylogeny.treefile")
tree.dist = cophenetic(tree)
ID = sort(colnames(tree.dist))
spec_mat = as.matrix(spec.mean)
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
spec.mean = aggregate(spec_all,
by = meta(spec_all)$Name,
mean, try_keep_txt(mean))
mean.meta = meta(spec.mean)
spec_mat = as.matrix(spec.mean)
tree = read.tree(file = "dryas_phylogeny.treefile")
tree.dist = cophenetic(tree)
spec_all = spec_all[!meta(spec_all)$Species_ID == "DX",]
spec.mean = aggregate(spec_all,
by = meta(spec_all)$Name,
mean, try_keep_txt(mean))
mean.meta = meta(spec.mean)
spec_mat = as.matrix(spec.mean)
View(tree.dist)
ID = sort(colnames(tree.dist))
ID
spec_mat = as.matrix(spec.mean)
View(spec_mat)
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
spec_all = spec_all[!meta(spec_all)$Species_ID == "DX",]
spec.mean = aggregate(spec_all,
by = meta(spec_all)$Name,
mean, try_keep_txt(mean))
mean.meta = meta(spec.mean)
write.csv(mean.meta, file = "mean_meta_new.csv")
ID
meta_new = read.csv("mean_meta_new.csv")
as.spectra(spec_mat)
spec = as.spectra(spec_mat)
meta_new = read.csv("mean_meta_new.csv", stringsAsFactors = F)
View(spec_mat)
View(meta_new)
meta_new = read.csv("mean_meta_new.csv", stringsAsFactors = F)
View(meta_new)
meta_new[,"genetic_name"]
rownames(spec_mat.new) <- meta_new[,"genetic_name"]
spec = as.spectra(spec_mat)
meta(spec) <- meta_new
spec_mat.new = as.matrix(spec)
rownames(spec_mat.new) <- meta_new[,"genetic_name"]
View(spec_mat)
View(spec_mat.new)
specID = sort(rownames(spec_mat.new))
setdiff(ID,specID)
setdiff(specID,ID)
spec_mat.new = spec_mat.new[!"tmi43_DA",]
View(spec_mat.new)
spec_mat.new = spec_mat.new[-"tmi43_DA",]
spec_mat.new = spec_mat.new[!rownames(spec_mat.new) == "tmi43_DA", ]
remove = setdiff(ID,specID)
tree = read.tree(file = "dryas_phylogeny.treefile")
tree.dist = cophenetic(tree)
remove = setdiff(ID,specID)
tree.dist = [!rownames(tree.dist) %in% remove, ]
tree.dist = tree.dist[!rownames(tree.dist) %in% remove, ]
tree.dist = tree.dist[!colnames(tree.dist) %in% remove, ]
tree.dist = tree.dist[, !colnames(tree.dist) %in% remove]
library(spectrolab)
library(ape)
library(phytools)
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0")
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
spec_all = spec_all[!meta(spec_all)$Species_ID == "DX",]
spec.mean = aggregate(spec_all,
by = meta(spec_all)$Name,
mean, try_keep_txt(mean))
spec.mean = as.matrix(spec.mean)
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
spec_all = spec_all[!meta(spec_all)$Species_ID == "DX",]
spec.mean = aggregate(spec_all,
by = meta(spec_all)$Name,
mean, try_keep_txt(mean))
spec.mean = as.matrix(spec.mean)
#change row names
meta_new = read.csv("mean_meta_new.csv", stringsAsFactors = F)
rownames(spec.mean) <- meta_new[, "genetic_name"]
#Genetic distance matrix
tree = read.tree(file = "dryas_phylogeny.treefile")
tree.dist = cophenetic(tree)
#Make sure both matrices have same sample IDs
gene.ID = colnames(tree.dist)
spec.ID = rownames(spec.mean)
remove.gene = setdiff(gene.ID, spec.ID)
remove.spec = setdiff(spec.ID, gene.ID)
remove.gene
tree.dist = tree.dist[!rownames(tree.dist) %in% remove.gene, ]
tree.dist = tree.dist[,!colnames(tree.dist) %in% remove.gene]
spec.mean = spec.mean[!rownames(spec.mean) %in% remove.spec]
setdiff(colnames(tree.dist),rownames(spec.mean))
spec2 = as.matrix(spec.mean)
View(spec2)
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
spec_all = spec_all[!meta(spec_all)$Species_ID == "DX",]
spec.mean = aggregate(spec_all,
by = meta(spec_all)$Name,
mean, try_keep_txt(mean))
spec.mean = as.matrix(spec.mean)
View(spec.mean)
meta_new = read.csv("mean_meta_new.csv", stringsAsFactors = F)
rownames(spec.mean) <- meta_new[, "genetic_name"]
tree = read.tree(file = "dryas_phylogeny.treefile")
tree.dist = cophenetic(tree)
gene.ID = colnames(tree.dist)
spec.ID = rownames(spec.mean)
remove.gene = setdiff(gene.ID, spec.ID)
remove.spec = setdiff(spec.ID, gene.ID)
tree.dist = tree.dist[!rownames(tree.dist) %in% remove.gene, ]
tree.dist = tree.dist[,!colnames(tree.dist) %in% remove.gene]
spec2 = spec.mean[!rownames(spec.mean) %in% remove.spec,]
spec2 = spec.mean[!rownames(spec.mean) == "tmi43_DA",]
View(spec2)
nrow(spec2)
spec.mean = spec.mean[!rownames(spec.mean) == "tmi43_DA",]
?dist
#calculate distance
spec_all_dist = dist(spec_mean, method = "euclidean", diag = T, upper = T)
#calculate distance
spec_all_dist = dist(spec.mean, method = "euclidean", diag = T, upper = T)
#calculate distance
spec.dist = dist(spec.mean, method = "euclidean", diag = T, upper = T)
dist2 = as.matrix(spec.dist)
View(dist2)
?mantel.test
#spectra
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
spec_all = spec_all[!meta(spec_all)$Species_ID == "DX",]
spec.mean = aggregate(spec_all,
by = meta(spec_all)$Name,
mean, try_keep_txt(mean))
spec.mean = as.matrix(spec.mean)
#change row names
meta_new = read.csv("mean_meta_new.csv", stringsAsFactors = F)
rownames(spec.mean) <- meta_new[, "genetic_name"]
#Genetic distance matrix
tree = read.tree(file = "dryas_phylogeny.treefile")
tree.dist = cophenetic(tree)
#Make sure both matrices have same sample IDs
gene.ID = colnames(tree.dist)
spec.ID = rownames(spec.mean)
remove.gene = setdiff(gene.ID, spec.ID)
remove.spec = setdiff(spec.ID, gene.ID)
tree.dist = tree.dist[!rownames(tree.dist) %in% remove.gene, ]
tree.dist = tree.dist[,!colnames(tree.dist) %in% remove.gene]
spec.mean = spec.mean[!rownames(spec.mean) == "tmi43_DA",]
#calculate distance
spec.dist = as.matrix(dist(spec.mean,
method = "euclidean",
diag = T, upper = T))
#Compare matrices
mantel.test(spec.dist, tree.dist, nperm = 999, graph = T)
?mantel.test
#Compare matrices
mtest = mantel.test(spec.dist, tree.dist, nperm = 999, graph = T)
mtest$alternative
mtest$p
View(spec.dist)
View(tree.dist)
install.packages("ade4")
library(ade4)
mtest2 = mantel.rtest(spec.dist, tree.dist, nrepet = 999)
class(tree.dist)
sdist = as.dist(spec.dist)
tree.dist2 = as.dist(tree.dist)
spec.dist2 = as.dist(spec.dist)
tree.dist2 = as.dist(tree.dist)
mtest2 = mantel.rtest(spec.dist2, tree.dist2, nrepet = 999)
mtest2
#Compare matrices
mtest = mantel.test(spec.dist, tree.dist, nperm = 9999, graph = F)
mtest
plot(spec.dist, tree.dist)
plot(spec.dist2, tree.dist2)
View(tree.dist)
View(spec.dist)
