axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
spec_all = readRDS("lean-up/Vector_normalized/all_vn.rds")
names(spec_all) = meta(spec_all)$Species
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
#add location as variable
spec_loc_mat_s = cbind(as.factor(spec_all.df$Location), spec_mat_s)
spec_mat   = spec_loc_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 20)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(26)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 16)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,16]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
spec_all = readRDS("lean-up/Vector_normalized/all_vn.rds")
oct = spec_all[meta(spec_all)$Species == "octopetala",]
names(oct) = meta(oct)$Location
oct.df = as.data.frame(oct)
#resample by every 10 nm
spec_small = resample(oct, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
spec_all = readRDS("Clean-up/Vector_normalized/all_vn.rds")
oct = spec_all[meta(spec_all)$Species == "octopetala",]
names(oct) = meta(oct)$Location
oct.df = as.data.frame(oct)
#resample by every 10 nm
spec_small = resample(oct, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(25)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 24)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,24]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = .55)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = .55)
#data
big3 = readRDS("Clean-up/Vector_normalized/vn_big3.rds")
big3 = readRDS("Clean-up/Vector_normalized/vn_big3.rds")
names(big3) = meta(big3)$Species
big3.m = as.matrix(big3)
big3.df = as.data.frame(big3)
#Resample by 10 nm
spec_small = resample(big3, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(27)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 25)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,25]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
big3 = readRDS("Clean-up/Vector_normalized/vn_big3.rds")
names(big3) = meta(big3)$Species
big3.m = as.matrix(big3)
big3.df = as.data.frame(big3)
#resample by every 10 nm
spec_small = resample(big3, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
#add location as variable
spec_loc_mat_s = cbind(as.factor(big3.df$Location), spec_mat_s)
spec_mat = spec_loc_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#Determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
###Ncomp = 25
#Run PLSDA
set.seed(28)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 25)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,25]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
no_hybrids = readRDS("Clean-up/Vector_normalized/vn_big3.no_hybrids.rds")
names(no_hybrids) = meta(no_hybrids)$Species
no_hybrids.m = as.matrix(no_hybrids)
no_hybrids.df = as.data.frame(no_hybrids)
#resample by 10 nm
spec_small = resample(no_hybrids, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
saveRDS(perf.plsda, "perf.plsda.rds")
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(2543)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 15)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,15]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
#data
no_hybrids = readRDS("Clean-up/Vector_normalized/vn_big3.no_hybrids.rds")
names(no_hybrids) = meta(no_hybrids)$Species
no_hybrids.m = as.matrix(no_hybrids)
no_hybrids.df = as.data.frame(no_hybrids)
#Resample by every 10 nm
spec_small = resample(no_hybrids, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_loc_mat_s = cbind(as.factor(no_hybrids.df$Location), spec_mat_s)
spec_mat = spec_loc_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "vertical")
set.seed(29)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 16)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,16]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
no_hybrids = readRDS("Clean-up/Vector_normalized/vn_big3.no_hybrids.rds")
names(no_hybrids) = meta(no_hybrids)$Location
no_hybrids.m = as.matrix(no_hybrids)
no_hybrids.df = as.data.frame(no_hybrids)
#resample by 10 nm
spec_small = resample(no_hybrids, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
saveRDS(perf.plsda, "perf.plsda.rds")
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
#run plsda
set.seed(2543)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 11)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,11]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
big3 = readRDS("Clean-up/Vector_normalized/vn_big3.rds")
names(big3) = meta(big3)$Location
big3.m = as.matrix(big3)
big3.df = as.data.frame(big3)
#Resample by 10 nm
spec_small = resample(big3, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 10)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
set.seed(27)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 13)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,25]
# calculate the error rate of the model
confusion.mat = get.confusion_matrix(truth = resp[test], predicted = prediction)
cm1 = as.data.frame(confusion.mat)
get.BER(confusion.mat)
#plot
par(mar = c(2, 4, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
par(mar = c(2, 5, 3, 4), oma = c(2, 4, 3, 2))
color2D.matplot(cm1,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(cm1)) - 0.5,
labels = names(cm1), tick = FALSE, cex.axis = 1)
axis(2, at = seq_len(nrow(cm1)) -0.5,
labels = rev(rownames(cm1)), tick = FALSE, las = 1, cex.axis = 1)
library(spectrolab)
library(dplyr)
library(ggpubr)
setwd("C:/Users/istas/OneDrive/Documents/Dryas Research/Dryas 2.0/Clean-up/Clean_spectra")
clean_all = readRDS("clean_all.rds")
oct = meta(clean_all[meta(clean_all)$Species == "octopetala", ])
oct
wilcox.test(LMA ~ Location, data = meta(oct), paired = F)
oct = clean_all[meta(clean_all)$Species == "octopetala", ]
wilcox.test(LMA ~ Location, data = meta(oct), paired = F)
meta(oct)
es_tm = oct[meta(oct)$Location == c("Twelve Mile", "Eagle Summit"),]
es_tm
meta(es_tm)
unique(meta(oct)$Location)
wilcox = function(x,locations){
lma1 = x[meta(x)$Location == locations,]
wilcox.test(LMA ~ Species, data = meta(lma1), paired = F)
}
oct = clean_all[meta(clean_all)$Species == "octopetala", ]
es_tm = c("Eagle Summit", "Twelve Mile")
o_es_tm = wilcox(oct, locations = es_tm)
wilcox = function(x,locations){
lma1 = x[meta(x)$Location == locations,]
wilcox.test(LMA ~ Location, data = meta(lma1), paired = F)
}
oct = clean_all[meta(clean_all)$Species == "octopetala", ]
es_tm = c("Eagle Summit", "Twelve Mile")
o_es_tm = wilcox(oct, locations = es_tm)
oe_es_tm
o_es_tm
oct = clean_all[meta(clean_all)$Species == "octopetala", ]
es_tm = c("Eagle Summit", "Twelve Mile")
es_bg = c("Eagle Summit", "Bison Gulch")
es_mdb = c("Eagle Summit", "Murphy Dome B")
es_wda = c("Eagle Summit", "Wickersham Dome A")
es_wdb = c("Eagle Summit", "Wickersham Dome B")
tm_bg = c("Twelve Mile", "Bison Gulch")
tm_mdb = c("Twelve Mile", "Murphy Dome B")
tm_wda = c("Twelve Mile", "Wickersham Dome A")
tm_wdb = c("Twelve Mile", "Wickersham Dome B")
bg_mdb = c("Bison Gulch", "Murphy Dome B")
bg_wda = c("Bison Gulch", "Wickersham Dome A")
bg_wdb = c("Bison Gulch", "Murphy Dome A")
mdb_wda = c("Murphy Dome B", "Wickersham Dome A")
mdb_wdb = c("Murphy Dome B", "Wickersham Dome B")
wda_wdb = c("Wickersham Dome A", "Wickersham Dome B")
o_es_tm = wilcox(oct, locations = es_tm)
View(o_es_tm)
o_es_tm
o_es_bg = wilcox(oct, locations = es_bg)
o_es_bg
o_es_mdb = wilcox(oct, locations = es_mdb)
o_es_mdb
o_es_wda = wilcox(oct, locations = es_wda)
o_es_wda
o_es_wdb = wilcox(oct, locations = es_wdb)
o_es_wdb
o_tm_bg = wilcox(oct, locations = tm_bg)
o_tm_bg = wilcox(oct, locations = tm_bg)
o_tm_mdb = wilcox(oct, locations = tm_mdb)
o_tm_wda = wilcox(oct, locations = tm_wda)
o_bg_mdb = wilcox(oct, locations = bg_mdb)
View(o_tm_bg)
o_tm_bg
o_tm_mdb = wilcox(oct, locations = tm_mdb)
o_tm_wda = wilcox(oct, locations = tm_wda)
o_tm_wdb = wilcox(oct, locations = tm_wdb)
o_bg_mdb = wilcox(oct, locations = bg_mdb)
o_bg_wda = wilcox(oct, locations = bg_wda)
o_bg_wdb = wilcox(oct, locations = bg_wdb)
o_mdb_wda = wilcox(oct, locations = mdb_wda)
o_mdb_wdb = wilcox(oct, locations = mdb_wdb)
o_wda_wdb = wilcox(oct, locations = wda_wdb)
o_bg_mdb = wilcox(oct, locations = bg_mdb)
o_tm_bg
o_tm_mdb
o_tm_wda
o_tm_wdb
o_bg_mdb
o_bg_wda
o_bg_wdb = wilcox(oct, locations = bg_wdb)
bg_wdb = c("Bison Gulch", "Wickersham Dome B")
o_bg_wdb = wilcox(oct, locations = bg_wdb)
o_bg_wdb
o_mdb_wda
o_mdb_wdb
o_wda_wdb
a_es_tm = wilcox(ala, locations = es_tm)
a_es_wdb = wilcox(ala, locations = es_wdb)
a_tm_wdb = wilcox(ala, locations = tm_wdb)
ala = clean_all[meta(clean_all)$Species == "alaskensis", ]
a_es_tm = wilcox(ala, locations = es_tm)
a_es_wdb = wilcox(ala, locations = es_wdb)
a_tm_wdb = wilcox(ala, locations = tm_wdb)
a_es_tm
a_es_wdb
a_tm_wdb
