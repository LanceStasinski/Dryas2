prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
mat2 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(3)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
mat3 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(4)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
mat4 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(5)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
mat5 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(6)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
mat6 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(7)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
mat7 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(8)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
mat8 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(9)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
mat9 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(10)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
mat10 = get.confusion_matrix(truth = resp[test], predicted = prediction)
mat.total = (mat1 + mat2 + mat3 + mat4 + mat5 + mat6 + mat7 + mat8 + mat9 + mat10)/10
saveRDS(mat.total, "Figures/raw confusion matrices/sp_mat.rds")
pops.cm = as.data.frame(mat.total)
get.BER(mat.total)
par(mar = c(2, 5, 5, 1), oma = c(2, 4, 3, 2))
color2D.matplot(pops.cm,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(pops.cm)) - 0.5,
labels = c("DA", "DO", "DX"),
tick = FALSE, cex.axis = 1, line = -.5)
axis(2, at = seq_len(nrow(pops.cm)) -0.5,
labels = rev(rownames(pops.cm)), tick = FALSE, las = 1, cex.axis = 1, line = -.5)
mtext("Ncomps:27    BER:0.2585264    Iterations:10", side = 1,
line = 1)
mtext("Actual Species", side = 2, line = 3, cex = 1.5)
mtext("Predicted Species", side = 3, line = 2, cex =1.5)
################################################################################
# Fit PLS_DA model all dry
################################################################################
#data
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
unique(meta(spec_all)$Location)
head(meta(spec_all))
spec_all = readRDS("Clean-up/Clean_spectra/clean_all.rds")
names(spec_all) = meta(spec_all)$Location
spec_all.m = as.matrix(spec_all)
spec_all.df = as.data.frame(spec_all)
#Resample by every 10 nm
spec_small = resample(spec_all, seq(400, 2400, by = 10))
spec_mat_s = as.matrix(spec_small)
spec_mat = spec_mat_s
resp = rownames(spec_mat)
rownames(spec_mat) = seq(nrow(spec_mat))
#determine number of components to use
plsda.fit = plsda(spec_mat, resp, ncomp = 30)
perf.plsda = perf(plsda.fit, validation = "Mfold", folds = 5,
progressBar = TRUE, auc = TRUE, nrepeat = 50)
plot(perf.plsda, col = color.mixo(1:3), sd = TRUE,
legend.position = "horizontal")
#Run PLSDA
set.seed(10)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,24]
# calculate the error rate of the model
mat10 = get.confusion_matrix(truth = resp[test], predicted = prediction)
get.BER(mat10)
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,30]
# calculate the error rate of the model
mat10 = get.confusion_matrix(truth = resp[test], predicted = prediction)
get.BER(mat10)
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,29]
# calculate the error rate of the model
mat10 = get.confusion_matrix(truth = resp[test], predicted = prediction)
get.BER(mat10)
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat10 = get.confusion_matrix(truth = resp[test], predicted = prediction)
get.BER(mat10)
prediction <- test.predict$class$max.dist[,27]
# calculate the error rate of the model
mat10 = get.confusion_matrix(truth = resp[test], predicted = prediction)
get.BER(mat10)
set.seed(1)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat1 = get.confusion_matrix(truth = resp[test], predicted = prediction)
#Run PLSDA
set.seed(2)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat2 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(3)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat3 = get.confusion_matrix(truth = resp[test], predicted = prediction)
#Run PLSDA
set.seed(4)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat4 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(5)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat5 = get.confusion_matrix(truth = resp[test], predicted = prediction)
#Run PLSDA
set.seed(6)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat6 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(7)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat7 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(8)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat8 = get.confusion_matrix(truth = resp[test], predicted = prediction)
set.seed(9)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat9 = get.confusion_matrix(truth = resp[test], predicted = prediction)
#Run PLSDA
set.seed(10)
samp <- sample(1:3, nrow(spec_mat), replace = TRUE)
# 1/3 of the data will compose the test set
test <- which(samp == 1)
# rest will compose the training set
train <- setdiff(1:nrow(spec_mat), test)
## For PLS-DA, train the model
plsda.train <- plsda(spec_mat[train, ], resp[train], ncomp = 30)
# then predict
test.predict <- predict(plsda.train, spec_mat[test, ], dist = "max.dist")
# store prediction for the 4th component
prediction <- test.predict$class$max.dist[,28]
# calculate the error rate of the model
mat10 = get.confusion_matrix(truth = resp[test], predicted = prediction)
mat.total = (mat1 + mat2 + mat3 + mat4 + mat5 + mat6 + mat7 + mat8 + mat9 + mat10)/10
saveRDS(mat.total, "Figures/raw confusion matrices/sp_mat.rds")
pops.cm = as.data.frame(mat.total)
get.BER(mat.total)
#plot
par(mar = c(2, 5, 5, 1), oma = c(2, 4, 3, 2))
color2D.matplot(pops.cm,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(pops.cm)) - 0.5,
labels = names(pops.cm),
tick = FALSE, cex.axis = 1, line = -.5)
axis(2, at = seq_len(nrow(pops.cm)) -0.5,
labels = rev(rownames(pops.cm)), tick = FALSE, las = 1, cex.axis = 1, line = -.5)
mtext("Ncomps:28    BER:0.02749489    Iterations:10", side = 1,
line = 1)
mtext("Actual Location", side = 2, line = 3, cex = 1.5)
mtext("Predicted Location", side = 3, line = 2, cex =1.5)
par(mar = c(2, 5, 5, 1), oma = c(2, 4, 3, 2))
color2D.matplot(pops.cm,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(pops.cm)) - 0.5,
labels = c("Bison Gulch", "Eagle Summit", "Murphy Dome B", "Twelve Mile", "Wickersham Dome A", "Wickersham Dome B"),
tick = FALSE, cex.axis = 1, line = -.5)
axis(2, at = seq_len(nrow(pops.cm)) -0.5,
labels = rev(rownames(pops.cm)), tick = FALSE, las = 1, cex.axis = 1, line = -.5)
mtext("Ncomps:28    BER:0.02749489    Iterations:10", side = 1,
line = 1)
mtext("Actual Location", side = 2, line = 6, cex = 1.5)
mtext("Predicted Location", side = 3, line = 2, cex =1.5)
par(mar = c(2, 8, 5, 1), oma = c(2, 4, 3, 2))
color2D.matplot(pops.cm,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(pops.cm)) - 0.5,
labels = c("Bison Gulch", "Eagle Summit", "Murphy Dome B", "Twelve Mile", "Wickersham Dome A", "Wickersham Dome B"),
tick = FALSE, cex.axis = 1, line = -.5)
axis(2, at = seq_len(nrow(pops.cm)) -0.5,
labels = rev(rownames(pops.cm)), tick = FALSE, las = 1, cex.axis = 1, line = -.5)
mtext("Ncomps:28    BER:0.02749489    Iterations:10", side = 1,
line = 1)
mtext("Actual Location", side = 2, line = 7, cex = 1.5)
mtext("Predicted Location", side = 3, line = 2, cex =1.5)
par(mar = c(2, 8, 5, 1), oma = c(2, 4, 3, 2))
color2D.matplot(pops.cm,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(pops.cm)) - 0.5,
labels = c("Bison Gulch", "Eagle Summit", "Murphy Dome B", "Twelve Mile", "Wickersham Dome A", "Wickersham Dome B"),
tick = FALSE, cex.axis = 1, line = -.5)
axis(2, at = seq_len(nrow(pops.cm)) -0.5,
labels = rev(rownames(pops.cm)), tick = FALSE, las = 1, cex.axis = 1, line = -.5)
mtext("Ncomps:28    BER:0.02749489    Iterations:10", side = 1,
line = 1)
mtext("Actual Location", side = 2, line = 9, cex = 1.5)
mtext("Predicted Location", side = 3, line = 2, cex =1.5)
par(mar = c(2, 8, 5, 1), oma = c(2, 4, 3, 2))
color2D.matplot(pops.cm,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(pops.cm)) - 0.5,
labels = c("Bison Gulch", "Eagle Summit", "Murphy Dome B", "Twelve Mile", "Wickersham Dome A", "Wickersham Dome B"),
tick = FALSE, cex.axis = 1, line = -.5)
axis(2, at = seq_len(nrow(pops.cm)) -0.5,
labels = rev(rownames(pops.cm)), tick = FALSE, las = 1, cex.axis = 1, line = -.5)
mtext("Ncomps:28    BER:0.02749489    Iterations:10", side = 1,
line = 1)
mtext("Actual Location", side = 2, line = 9.5, cex = 1.5)
mtext("Predicted Location", side = 3, line = 2, cex =1.5)
par(mar = c(2, 5, 5, 1), oma = c(2, 4, 3, 2))
color2D.matplot(pops.cm,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(pops.cm)) - 0.5,
labels = c("BG", "ES", "MDB", "TM", "WDA", "WDB"),
tick = FALSE, cex.axis = 1, line = -.5)
axis(2, at = seq_len(nrow(pops.cm)) -0.5,
labels = c("BG", "ES", "MDB", "TM", "WDA", "WDB"), tick = FALSE, las = 1,
cex.axis = 1, line = -.5)
mtext("Ncomps:28    BER:0.02749489    Iterations:10", side = 1,
line = 1)
mtext("Actual Location", side = 2, line = 5, cex = 1.5)
mtext("Predicted Location", side = 3, line = 2, cex =1.5)
#plot
par(mar = c(2, 5, 5, 1), oma = c(2, 4, 3, 2))
color2D.matplot(pops.cm,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(pops.cm)) - 0.5,
labels = c("BG", "ES", "MDB", "TM", "WDA", "WDB"),
tick = FALSE, cex.axis = 1, line = -.5)
axis(2, at = seq_len(nrow(pops.cm)) -0.5,
labels = c("BG", "ES", "MDB", "TM", "WDA", "WDB"), tick = FALSE, las = 1,
cex.axis = 1, line = -.5)
mtext("Ncomps:28    BER:0.02749489    Iterations:10", side = 1,
line = 1)
mtext("Actual Location", side = 2, line = 4, cex = 1.5)
mtext("Predicted Location", side = 3, line = 2, cex =1.5)
par(mar = c(2, 5, 5, 1), oma = c(2, 4, 3, 2))
color2D.matplot(pops.cm,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(pops.cm)) - 0.5,
labels = c("BG", "ES", "MDB", "TM", "WDA", "WDB"),
tick = FALSE, cex.axis = 1, line = -.5)
axis(2, at = seq_len(nrow(pops.cm)) -0.5,
labels = rev(c("BG", "ES", "MDB", "TM", "WDA", "WDB")), tick = FALSE, las = 1,
cex.axis = 1, line = -.5)
mtext("Ncomps:28    BER:0.02749489    Iterations:10", side = 1,
line = 1)
mtext("Actual Location", side = 2, line = 4, cex = 1.5)
mtext("Predicted Location", side = 3, line = 3, cex =1.5)
#plot
par(mar = c(2, 5, 5, 1), oma = c(2, 4, 3, 2))
color2D.matplot(pops.cm,
show.values = TRUE,
axes = FALSE,
xlab = "",
ylab = "",
vcex = 2,
vcol = "black",
extremes = c("white", "deepskyblue3"))
axis(3, at = seq_len(ncol(pops.cm)) - 0.5,
labels = c("BG", "ES", "MDB", "TM", "WDA", "WDB"),
tick = FALSE, cex.axis = 1, line = -.5)
axis(2, at = seq_len(nrow(pops.cm)) -0.5,
labels = rev(c("BG", "ES", "MDB", "TM", "WDA", "WDB")), tick = FALSE, las = 1,
cex.axis = 1, line = -.5)
mtext("Ncomps:28    BER:0.02749489    Iterations:10", side = 1,
line = 1)
mtext("Actual Location", side = 2, line = 4, cex = 1.5)
mtext("Predicted Location", side = 3, line = 2.5, cex =1.5)
